---
title: "Modeller med sol-, vind- og totalproduktion"
author: Gruppe MO6-2"
date: "2025-03-12"
output: html_document
---



```{r}
# Opsætning og indlæsning af nødvendige libraries
Sys.setlocale("LC_TIME", "C") 
library(dplyr)       
library(jsonlite)   
library(httr)      
library(danstat)   
library(magrittr)   
library(purrr)     
library(lubridate)
library(zoo)    
library(xts)       
library(tseries)    
library(forecast)
library("fpp3")
library(data.table)
```

```{r}
# Elpriser fra december 2024 til februar 2025 (3 måneder)
spotPrices <- GET("https://api.energidataservice.dk/dataset/ElspotPrices?start=2024-12-01T00:00&end=2025-02-28T00:00")

# Konverter fra json
spotPrices <- fromJSON(rawToChar(spotPrices$content))

# Konverter til data table og begræns til "DK1" (Vest Danmark)
spotPrices <- data.table(spotPrices$records)
spotPrices <- subset(spotPrices, PriceArea %in% c("DK1"))
spotPrices <- spotPrices |> mutate(SpotPriceDKK = if_else(SpotPriceDKK == 0, NA, SpotPriceDKK))

# Fjern unødvendige søjler
spotPrices <- subset(spotPrices, select = -c(PriceArea, SpotPriceEUR))

# Lav HourDK om til POSIXct format
spotPrices$HourDK <- as.POSIXct(spotPrices$HourDK, format = "%Y-%m-%dT%H:%M:%S")
spotPrices$logspotprice <- imputeTS::na_interpolation(log(spotPrices$SpotPriceDKK))

#Gem som RDS
saveRDS(spotPrices, "spotprices.rds")
spotPrices <- readRDS("spotprices.rds")

#Lav om til tsibble
library("tsibble")
spotPrices <- as_tsibble(spotPrices, index = HourDK)
spotPrices
```


```{r}
# Begræns til perioden 15/01/2025-15/02/2025 og tjek
train <- spotPrices |> filter(between(row_number(), 1081, 1848))
head(train)
tail(train)
```

```{r}
#Deterministisk trend-komponent:
t <-  seq(nrow(train))

# Modellér KUN deterministisk sæson og trend med DHR (både dags- og ugesæson):
fit_dhr <- train |>
  model(dhr = ARIMA(logspotprice ~ PDQ(0,0,0) + pdq(0,0,0) + t +
                      fourier(period = 24, K=6) + 
                      fourier(period = 7*24, K=5))) |>
              report() |> fitted() |> mutate(train$logspotprice)

#Udregn residualerne af den fittede model, kald dem "resids":
fit_dhr <- fit_dhr |> mutate(resids = train$logspotprice - .fitted, .model = NULL) 

#Plot ACF og PACF af residualerne
ggtsdisplay(fit_dhr$resids, plot_type = 'partial', lag = 100)

#KPSS og ADF
kpss.test(fit_dhr$resids) #Stationær
adf.test(fit_dhr$resids) #Stationær
```



```{r}
# Plot af log-prisen og den deterministiske trend+sæson komponent
fit_dhr |> 
  ggplot(aes(HourDK)) +
   geom_line(aes(y = train$logspotprice, colour = "Log Electricity Price (DKK)")) + 
   geom_line(aes(y = .fitted, colour = "Deterministic Season and Trend")) +
   labs(x = "Hour", y = "Log Electricity Price (DKK)") +
   theme(legend.position = "bottom")
```
```{r}
# Plot KUN deterministisk season og trend
fit_dhr |> 
  ggplot(aes(HourDK)) +
    geom_line(aes(y=.fitted), color="red") +
    labs(x = "Date", y = "Deterministic Season and Trend")
```

```{r}
# Plot log-prisen fratrukket fittet deterministisk sæson og trend, dvs. "SARMA" data
fit_dhr |> 
  ggplot(aes(HourDK)) +
  geom_line(aes(y=resids), , color="blue") +
  labs(x= "Date", y= "Log Price - Deterministic Trend and Season (SARMA data)")

#Navngiv ".fitted" som "deterministic" (deterministisk trend og sæson) og "resids" som "filtreret" (data som vil bruges som input til SARMA)
fit_dhr <-  fit_dhr |> rename(deterministisk = .fitted, filtreret = resids)

#Fit SARMA model på "filtreret" (residualerne), hvor vi selv bestemmer ARIMA ordren
fit_SARMA <- fit_dhr |>
  model(sarma = ARIMA(filtreret ~1+ PDQ(1,1,1,period=24) + pdq(1,0,1))) |>
  report() |> fitted() |> mutate(SARMAdata = fit_dhr$filtreret)

#Udregn residualerne af SARMA modellen
fit_SARMA <-  fit_SARMA |> rename(SARMAfit = .fitted) |>
    mutate(SARMAresids = SARMAdata - SARMAfit, .model = NULL)

#Plot ACF og PACF af SARMA modellens residualer
acf(fit_SARMA$SARMAresids, na.action = na.pass, lag.max = 100,
    main = "ACF of SARMA Model Residuals")
pacf(fit_SARMA$SARMAresids, na.action = na.pass, lag.max = 100,
    main = "PACF of SARMA Model Residuals")
#Plot ACF og PACF
ggtsdisplay(fit_SARMA$SARMAresids, plot_type = 'partial', lag = 100)

```

```{r}
# Plot af originale SARMA data vs SARMA data fra modellen
fit_SARMA |> 
  ggplot(aes(HourDK)) +
  geom_line(aes(y=SARMAdata, colour = "Original Random Component")) + 
  geom_line(aes(y=SARMAfit, colour = "Fitted values from SARMA")) + 
  labs(y = "SARMA data") +  labs(x = "Hour")+
   theme(legend.position = "bottom")
```
```{r}
# Plot af originale SARMA data fratrukket fittet SARMA
fit_SARMA |> 
  ggplot(aes(HourDK)) +
  geom_line(aes(y = SARMAresids)) +
  labs(y = "SARIMA(1,0,1)(1,1,1) Model Residuals") + labs(x = "Hour") 
```

```{r}
#Ljung-Box for selvvalgt model

# Vælg antal lags
max_lag <- 20

# Udregn Ljung-Box test p-værdier for de forskellige lags
ljung_box_results <- map_df(1:max_lag, ~ data.frame(
  lag = .x,
  p_value = Box.test(fit_SARMA$SARMAresids, lag = .x, type = "Ljung-Box")$p.value
))

# Plot Ljung Box p-værdierne
ggplot(ljung_box_results, aes(x = lag, y = p_value)) +
  geom_point(shape = 16, size = 3) +  # Closed circles
  geom_segment(aes(x = lag, xend = lag, y = 0, yend = p_value), linetype = "solid") +  
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "blue") +  
  labs(title = "Ljung-Box Test p-values",
       x = "Lag",
       y = "p-value") +
  theme_minimal()
```

```{r}
#Auto arima på random komponenten

fit <- auto.arima(fit_SARMA$SARMAdata)
fit$arma # Print SARIMA ordren
summary(fit)

#Tjek residualerne af "fit" modellen (modellen for random komponenten)
ggtsdisplay(fit$residuals, plot_type = 'partial', lag = 100)
```
```{r}
# Afgør den kombination af K1 og K2, der giver den bedste model 
#best_aicc <- Inf
#best_model <- NULL
#best_K1 <- NA
#best_K2 <- NA

# Modellér trend
#t <- seq(nrow(train))

# Tilføj t til trend
#train <- train |> mutate(t = t)

#for (K1 in 1:6) {
#  for (K2 in 1:6) {
    # Fit deterministic model with current K1 and K2
#    fit_dhr <- tryCatch({
#      train |>
#        model(
#          dhr = ARIMA(logspotprice ~ PDQ(0, 0, 0) + pdq(0, 0, 0) + t +
#                        fourier(period = 24, K = K1) +
#                        fourier(period = 7 * 24, K = K2))
#        ) |>
#        fitted()
#    }, error = function(e) return(NULL))

    # Udregn residualerne = logspotprice - deterministic component
#    fit_dhr <- fit_dhr |> mutate(SARMAdata = train$logspotprice - .fitted)

    # Fit auto.arima til SARMAdata
 #   fit <- tryCatch({
 #     auto.arima(fit_dhr$SARMAdata)
 #   }, error = function(e) return(NULL))

 #   if (is.null(fit)) next

    # Gem den bedste model baseret på AICc
 #   if (fit$aicc < best_aicc) {
  #    best_aicc <- fit$aicc
#      best_model <- fit
  #    best_K1 <- K1
 #     best_K2 <- K2
#    }
 # }
#}

# Print summary for den bedste model
#cat("Best model found with:\n")
#cat("  K1 (daily Fourier):", best_K1, "\n")
#cat("  K2 (weekly Fourier):", best_K2, "\n")
#cat("  Best AICc:", best_aicc, "\n")
#summary(best_model)
```


```{r}
# Forecast random komponenten
forecast_random <- forecast(fit, h = 24)

# Eksisterende data (fittede værdier)
history_df <- data.frame(
  time = as.numeric(time(fitted(fit))),
  value = as.numeric(fitted(fit))
)

# Prædikteret data
forecast_df <- data.frame(
  time = as.numeric(time(forecast_random$mean)),
  mean = as.numeric(forecast_random$mean),
  lower = as.numeric(forecast_random$lower[, 2]),  # 95% lower bound
  upper = as.numeric(forecast_random$upper[, 2])   # 95% upper bound
)

# Kombinér i ét plot
ggplot() +
  geom_line(data = history_df, aes(x = time, y = value), color = "black") +
  geom_ribbon(data = forecast_df, aes(x = time, ymin = lower, ymax = upper), 
              fill = "lightblue", alpha = 0.5) +
  geom_line(data = forecast_df, aes(x = time, y = mean), color = "blue") +
  labs(
    title = "1 days forecast of the random component",
    x = "Time",
    y = "Value"
  ) +
  theme_minimal()

```



```{r}

# === Forecast uden eksterne variable  ===

# Deterministisk trend-komponent:
t <- seq(nrow(train))  # Trend for træningsdata

# Udvid t til også at inkludere fremtiden (25 fremtidige timer)
t_future <- max(t) + seq_len(25)

# Generér tidspunkter for de næste 25 timer
future_hours <- tibble(HourDK = max(train$HourDK) + seq(1, 25) * 3600) |> 
  as_tsibble(index = HourDK)

# Tilføj t og fourier-værdier til future_hours
future_hours <- future_hours |> 
  mutate(t = t_future) |> 
  bind_cols(
    as_tibble(fourier(ts(train$logspotprice, frequency = 24), K = 6, h = 25)),
    as_tibble(fourier(ts(train$logspotprice, frequency = 7*24), K = 5, h = 25))
  )

# Fit deterministisk trend og sæsonkomponent model med DHR-metoden fra Hyndman
fit_dhr <- train |> 
  model(dhr = ARIMA(logspotprice ~ PDQ(0,0,0) + pdq(0,0,0) + t +
                      fourier(period = 24, K = 6) +  
                      fourier(period = 7*24, K = 5))) 

# Forecast den deterministiske trend og sæsonkomponent for de næste 25 timer
future_deterministic <- forecast(fit_dhr, new_data = future_hours)

# Forecast random komponenten for næste 25 timer
forecast_random <- forecast(fit, h = 25)
forecast_random <- as_fable(forecast_random)  # Konverter forecast til fable-struktur

# Kombinér tidspunkter med den stokastiske forecast-komponent
forecast_random <- future_hours |> 
  bind_cols(as_tibble(forecast_random)) |> 
  rename(forecast_random = .mean)

# Konverter deterministisk forecast og omdøb
future_deterministic <- as_tibble(future_deterministic) |> 
  rename(forecast_deterministic = .mean)

# Kombinér deterministisk og stokastisk komponent og transformér tilbage til faktisk pris
combined_forecast <- future_deterministic |> 
  left_join(forecast_random, by = "HourDK") |> 
  mutate(final_forecast = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, final_forecast) |> 
  as_tsibble(index = HourDK)

print(combined_forecast)

# Visualiser det endelige forecast af elprisen for 1 dag
ggplot(combined_forecast, aes(x = HourDK, y = final_forecast)) +
  geom_line(color = "blue", size = 1) +
  labs(title = "Final Forecast of Electricity Price for 1 Day",
       x = "Hour",
       y = "Forecasted Price") +
  theme_minimal()
```





```{r}
#Ljung-Box for auto modellen

# Vælg antal lags
max_lag <- 10

# Udregn Ljung-Box test p-værdier for de forskellige lags
ljung_box_results <- map_df(1:max_lag, ~ data.frame(
  lag = .x,
  p_value = Box.test(fit$residuals, lag = .x, type = "Ljung-Box")$p.value
))

# Plot Ljung Box p-værdierne
ggplot(ljung_box_results, aes(x = lag, y = p_value)) +
  geom_point(shape = 16, size = 3) +  
  geom_segment(aes(x = lag, xend = lag, y = 0, yend = p_value), linetype = "solid") + 
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "blue") + 
  scale_x_continuous(breaks = seq(1, max_lag, by = 1)) +  
  labs(title = "Ljung-Box Test p-values",
       x = "Lag",
       y = "p-value") +
  theme_minimal()
```

```{r}
#Elproduktions-data (vind, sol og samlet)
productionConsumption <- GET("https://api.energidataservice.dk/dataset/productionConsumptionSettlement?start=2024-12-01T00:00&end=2025-02-28T00:00")

#Konverter fra JSON
productionConsumption <- fromJSON(rawToChar(productionConsumption$content))

#Konverter til dataframe
productionConsumption <- data.frame(productionConsumption$records)

# Begræns data til DK1
productionConsumption <- subset(productionConsumption, PriceArea %in% c("DK1"))
```


```{r}
# Opret 4 nye søjler: total wind, total solar, total production
productionConsumption <- productionConsumption %>%
  dplyr::mutate(
    totalWind = OffshoreWindLt100MW_MWh + OffshoreWindGe100MW_MWh +
                OnshoreWindLt50kW_MWh + OnshoreWindGe50kW_MWh,
    
    totalSun = SolarPowerLt10kW_MWh + SolarPowerGe10Lt40kW_MWh +
               SolarPowerGe40kW_MWh + SolarPowerSelfConMWh,
    
    totalProduction = CentralPowerMWh + LocalPowerMWh + CommercialPowerMWh + LocalPowerSelfConMWh +
                      OffshoreWindLt100MW_MWh + OffshoreWindGe100MW_MWh +
                      OnshoreWindLt50kW_MWh + OnshoreWindGe50kW_MWh +
                      HydroPowerMWh +
                      SolarPowerLt10kW_MWh + SolarPowerGe10Lt40kW_MWh +
                      SolarPowerGe40kW_MWh + SolarPowerSelfConMWh +
                      UnknownProdMWh
  )

  
  #Bevar kun de relevante søjler
  productionConsumption <- productionConsumption %>%
  select(HourDK, totalSun, totalWind, totalProduction)


#Formattering af dato som PSIX
productionConsumption$HourDK <- as.POSIXct(productionConsumption$HourDK, format = "%Y-%m-%dT%H:%M:%S")

#Gem som RDS
saveRDS(productionConsumption, "productionConsumptions.rds")
productionConsumption <- readRDS("productionConsumptions.rds")

#Konverter til tsibble
productionConsumption <- as_tsibble(productionConsumption, index = HourDK)
productionConsumption
```




```{r}
#Begræns træningsdata til 15/01/2025–15/02/2025

train_production <- productionConsumption |> 
  filter(between(row_number(), 1081, 1848))
head(train_production)
tail(train_production)

#Plot produktionen (vælg evt. selv, hvad der skal plottes på y-aksen)

ggplot(train_production, aes(x = HourDK, y = totalProduction)) +
  geom_line(color = "black") +
  ggtitle("Total Electricity Production") +
  xlab("Date") + 
  ylab("Total Electricity Production (MWh)")
```

```{r}
# === Modeller med sol som xreg med forskellige lags ===

# Antal observationer i træningsdata
n <- nrow(train_production)

# === Lag 0 ===
xreg_sun_lag0 <- log(train_production$totalSun)
model_sun_lag0 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_sun_lag0)
cat("\n=== MODEL: Solproduktion med 0 timers lag ===\n")
summary(model_sun_lag0)

# === Lag 1 ===
last_sun_value <- productionConsumption$totalSun[1080]  # 1 time før træningsdata starter
xreg_sun_lag1 <- c(last_sun_value, train_production$totalSun[-n]) |> log()
model_sun_lag1 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_sun_lag1)
cat("\n=== MODEL: Solproduktion med 1 times lag ===\n")
summary(model_sun_lag1)

# === Lag 2 ===
last_sun_values_2 <- productionConsumption$totalSun[1079:1080]
xreg_sun_lag2 <- c(last_sun_values_2, train_production$totalSun[-c(n - 1, n)]) |> log()
model_sun_lag2 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_sun_lag2)
cat("\n=== MODEL: Solproduktion med 2 timers lag ===\n")
summary(model_sun_lag2)

# === Lag 24 ===
lag_n <- 24
last_sun_values_24 <- productionConsumption$totalSun[(1081 - lag_n):(1080)]
xreg_sun_lag24 <- c(last_sun_values_24, train_production$totalSun[1:(n - lag_n)]) |> log()
model_sun_lag24 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_sun_lag24)
cat("\n=== MODEL: Solproduktion med 24 timers lag ===\n")
summary(model_sun_lag24)
```
```{r}
#Forecast af modellen med soldata som xreg-variablen 

# Deterministisk trend-komponent:
t <- seq(nrow(train))  # Trend for træningsdata

# Udvid t til også at inkludere fremtiden (25 fremtidige timer)
t_future <- max(t) + seq_len(25)

# Generér tidspunkter for de næste 25 timer
future_hours <- tibble(HourDK = max(train$HourDK) + seq(1, 25) * 3600) |> 
  as_tsibble(index = HourDK)

# Tilføj t og fourier-værdier til future_hours
future_hours <- future_hours |> 
  mutate(t = t_future) |> 
  bind_cols(
    as_tibble(fourier(ts(train$logspotprice, frequency = 24), K = 6, h = 25)),
    as_tibble(fourier(ts(train$logspotprice, frequency = 7*24), K = 5, h = 25))
  )

# Fit deterministisk trend og sæsonkomponent model med DHR-metoden fra Hyndman
fit_dhr <- train |> 
  model(dhr = ARIMA(logspotprice ~ PDQ(0,0,0) + pdq(0,0,0) + t +
                      fourier(period = 24, K = 6) +  
                      fourier(period = 7*24, K = 5))) 

# Forecast den deterministiske trend og sæsonkomponent for de næste 25 timer
future_deterministic <- forecast(fit_dhr, new_data = future_hours)

# Hent xreg-værdier for d. 16. februar (plus 1 time = 25 timer i alt)
future_production <- productionConsumption |>
  filter(HourDK >= as.POSIXct("2025-02-16 00:00:00") &
         HourDK <= as.POSIXct("2025-02-17 00:00:00"))

# Tag log af de fremtidige x-reg værdier
xreg_future <- log(future_production$totalSun)

# Forecast fremtidige random komponent for 25 timer
forecast_random <- forecast(model_incl_xreg, xreg = xreg_future)

# Konvertér til fable
forecast_random <- as_fable(forecast_random)

# Kombinér tidspunkter med forecast for stokastisk komponent
forecast_random <- future_hours |> 
  bind_cols(as_tibble(forecast_random)) |> 
  rename(forecast_random = .mean)

# Konverter deterministisk forecast og omdøb
future_deterministic <- as_tibble(future_deterministic) |> 
  rename(forecast_deterministic = .mean)

# Kombinér deterministisk og stokastisk komponent og transformér tilbage til faktisk pris
combined_forecast_xreg <- future_deterministic |> 
  left_join(forecast_random, by = "HourDK") |> 
  mutate(final_forecast = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, final_forecast) |> 
  as_tsibble(index = HourDK)

print(combined_forecast_xreg)

# Visualiser det endelige forecast
ggplot(combined_forecast_xreg, aes(x = HourDK, y = final_forecast)) +
  geom_line(color = "blue", size = 1) +
  labs(title = "Final Forecast of Electricity Price for 1 Day",
       x = "Hour",
       y = "Forecasted Price") +
  theme_minimal()

```

```{r}
#Hent de faktiske priser fra 16. februar
actual_prices_feb16 <- spotPrices |> 
  filter(between(row_number(), 1850, 1873)) |> 
  as_tsibble(index = HourDK)

#Tjek om priserne er hentet rigtigt
head(actual_prices_feb16)
tail(actual_prices_feb16)
```

```{r}
# === Modeller med vind som xreg  ===

# === Vind uden lag (0 timer) ===
xreg_0 <- log(train_production$totalWind)
model_lag0 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_0)
cat("\n=== MODEL: Vindproduktion med 0 timers lag ===\n")
summary(model_lag0)

# === Vind med 1 times lag ===
# Indsæt manglende laggede værdi (række 1080 = én time før træningsdatasættet)
last_wind_value <- productionConsumption$totalWind[1080]
xreg_1 <- c(last_wind_value, train_production$totalWind[-nrow(train_production)]) |> log()
model_lag1 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_1)
cat("\n=== MODEL: Vindproduktion med 1 times lag ===\n")
summary(model_lag1)

# === Vind med 2 timers lag ===
# Indsæt manglende laggede værdier (række 1079 og 1080 = to timer før træningsdatasættet)
last_wind_values_2 <- productionConsumption$totalWind[1079:1080]
xreg_2 <- c(last_wind_values_2, train_production$totalWind[-c(nrow(train_production)-1, nrow(train_production))]) |> log()
model_lag2 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_2)
cat("\n=== MODEL: Vindproduktion med 2 timers lag ===\n")
summary(model_lag2)

# === Vind med både 1 og 2 timers lag ===

# Hent de nødvendige værdier til at udfylde laggede værdier (før træningsperiode)
last_wind_values <- productionConsumption$totalWind[1079:1080]

# Lav vektor for lag 1: 1 time før træningsdata
xreg_lag1 <- c(last_wind_values[2], train_production$totalWind[-nrow(train_production)])

# Lav vektor for lag 2: 2 timer før træningsdata
xreg_lag2 <- c(last_wind_values, train_production$totalWind[-c(nrow(train_production)-1, nrow(train_production))])

# Log-transformér
xreg_lag1 <- log(xreg_lag1)
xreg_lag2 <- log(xreg_lag2)

# Lav matrix med matrix() funktionen
xreg_matrix <- matrix(
  data = c(xreg_lag1, xreg_lag2),  # Alle værdier i én lang vektors
  ncol = 2,                        # To kolonner: én for hver lag
  byrow = FALSE                   # Rækker = observationer
)

# Navngiv søjlerne
colnames(xreg_matrix) <- c("lag1", "lag2")

# Fit modellen
model_lag1_lag2 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_matrix)

cat("\n=== MODEL: Vindproduktion med lag 1 og 2 (matrix) ===\n")
summary(model_lag1_lag2)

# === Vind med 24 timers lag ===
# Antal observationer i træningsdata
n <- nrow(train_production)
lag_n <- 24

# Værdier 24 timer før træningsdata starter (dvs. rækkerne 1057-1080)
last_wind_values_24 <- productionConsumption$totalWind[(1081 - lag_n):(1080)]

# Kombinér med resten af træningsdata, ekskl. de sidste 24 observationer
xreg_wind_lag24 <- c(last_wind_values_24, train_production$totalWind[1:(n - lag_n)]) |> log()

# Fit modellen
model_wind_lag24 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_wind_lag24)

cat("\n=== MODEL: Vindproduktion med 24 timers lag ===\n")
summary(model_wind_lag24)

```



```{r}
# === Modeller med totalproduktion som xreg ===
# === Lag 0 ===
xreg_totalProd_0 <- log(train_production$totalProduction)
model_totalProd_0 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_totalProd_0)
summary(model_totalProd_0)

# === Lag 1 ===
last_val_1 <- productionConsumption$totalProduction[1080]
xreg_totalProd_1 <- c(last_val_1, train_production$totalProduction[-nrow(train_production)]) |> log()
model_totalProd_1 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_totalProd_1)
summary(model_totalProd_1)

# === Lag 2 ===
last_vals_2 <- productionConsumption$totalProduction[1079:1080]
xreg_totalProd_2 <- c(last_vals_2, train_production$totalProduction[-c(nrow(train)-1, nrow(train_production))]) |> log()
model_totalProd_2 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_totalProd_2)
summary(model_totalProd_2)

# === Lag 24 ===
lag_n <- 24
xreg_totalProd_24 <- c(
  productionConsumption$totalProduction[(1081 - lag_n):(1080)],
  train_production$totalProduction[1:(nrow(train_production) - lag_n)]
) |> log()
model_totalProd_24 <- auto.arima(fit_SARMA$SARMAdata, xreg = xreg_totalProd_24)
summary(model_totalProd_24)


#ACF og PACF af den bedste model
ggtsdisplay(model_totalProd_2$residuals, plot_type = 'partial', lag = 100)
```



```{r}
# Funktioner til udregning af RMSE og MAPE
rmse <- function(pred, actual) sqrt(mean((actual - pred)^2, na.rm = TRUE))
mape <- function(pred, actual) mean(abs((actual - pred) / actual), na.rm = TRUE) * 100

# === FÆLLES SETUP TIL FORECAST (25 fremtidige timer) ===
future_hours <- tibble(HourDK = max(train$HourDK) + seq(1, 25) * 3600) |> 
  as_tsibble(index = HourDK)

# === Forecast-funktion ===
make_forecast <- function(model, future_xreg, name) {
  forecast_random <- forecast(model, xreg = future_xreg) |> as_fable()
  combined <- future_deterministic |> 
    left_join(tibble(HourDK = future_hours$HourDK, forecast_random = forecast_random$.mean), by = "HourDK") |> 
    mutate(!!name := exp(forecast_deterministic + forecast_random)) |> 
    select(HourDK, !!name)
  return(combined)
}

# === Hent fremtidige produktionsdata ===
future_prod <- productionConsumption |> 
  filter(HourDK >= as.POSIXct("2025-02-15 00:00:00") & HourDK <= as.POSIXct("2025-02-17 00:00:00"))

# === Hjælpefunktion til lag ===
safe_lag <- function(series, lag_val) {
  lagged <- dplyr::lag(series, lag_val)
  lagged[(lag_val+1):(lag_val+25)] |> log()
}

# === XREG-værdier ===
xreg_values <- list(
  forecast_sun_lag0   = log(future_prod$totalSun[1:25]),
  forecast_sun_lag1   = safe_lag(future_prod$totalSun, 1),
  forecast_sun_lag2   = safe_lag(future_prod$totalSun, 2),
  forecast_sun_lag24  = safe_lag(future_prod$totalSun, 24),

  forecast_wind_lag0    = log(future_prod$totalWind[1:25]),
  forecast_wind_lag1    = safe_lag(future_prod$totalWind, 1),
  forecast_wind_lag2    = safe_lag(future_prod$totalWind, 2),
  forecast_wind_lag1_2  = matrix(
    c(
      safe_lag(future_prod$totalWind, 1),
      safe_lag(future_prod$totalWind, 2)
    ), ncol = 2
  ),
  forecast_wind_lag24   = safe_lag(future_prod$totalWind, 24),

  forecast_total_lag0   = log(future_prod$totalProduction[1:25]),
  forecast_total_lag1   = safe_lag(future_prod$totalProduction, 1),
  forecast_total_lag2   = safe_lag(future_prod$totalProduction, 2),
  forecast_total_lag24  = safe_lag(future_prod$totalProduction, 24)
)

# === Tilhørende modeller ===
model_list <- list(
  forecast_sun_lag0   = model_sun_lag0,
  forecast_sun_lag1   = model_sun_lag1,
  forecast_sun_lag2   = model_sun_lag2,
  forecast_sun_lag24  = model_sun_lag24,

  forecast_wind_lag0    = model_lag0,
  forecast_wind_lag1    = model_lag1,
  forecast_wind_lag2    = model_lag2,
  forecast_wind_lag1_2  = model_lag1_lag2,
  forecast_wind_lag24   = model_wind_lag24,

  forecast_total_lag0   = model_totalProd_0,
  forecast_total_lag1   = model_totalProd_1,
  forecast_total_lag2   = model_totalProd_2,
  forecast_total_lag24  = model_totalProd_24
)

# === Forecasts ===
forecast_no_xreg <- forecast_no_xreg


# Liste til forecasts
forecast_df_list <- list(forecast_no_xreg)

for (name in names(model_list)) {
  forecast_df_list[[name]] <- make_forecast(model_list[[name]], xreg_values[[name]], name)
}

# === Kombinér med faktiske priser ===
forecast_comparison_all <- actual_prices_feb16 |> 
  rename(actual = SpotPriceDKK)

for (df in forecast_df_list) {
  forecast_comparison_all <- left_join(forecast_comparison_all, df, by = "HourDK")
}


# === Udregn RMSE og MAPE ===
model_labels <- c(
  "Uden xreg",
  "Sol (lag 0)", "Sol (lag 1)", "Sol (lag 2)", "Sol (lag 24)",
  "Vind (lag 0)", "Vind (lag 1)", "Vind (lag 2)", "Vind (lag 1 & 2)", "Vind (lag 24)",
  "Total Prod (lag 0)", "Total Prod (lag 1)", "Total Prod (lag 2)", "Total Prod (lag 24)"
)

forecast_cols <- names(forecast_df_list)

metrics_all <- tibble(
  Model = model_labels,
  RMSE = map_dbl(forecast_cols, ~ rmse(forecast_comparison_all[[.x]], forecast_comparison_all$actual)),
  MAPE = map_dbl(forecast_cols, ~ mape(forecast_comparison_all[[.x]], forecast_comparison_all$actual))
)

# === Beregn RMSE og MAPE manuelt for modellen uden xreg ===
rmse_no_xreg <- rmse(forecast_comparison_all$forecast_no_xreg, forecast_comparison_all$actual)
mape_no_xreg <- mape(forecast_comparison_all$forecast_no_xreg, forecast_comparison_all$actual)

# === Erstat første række i tabellen med de korrekte værdier ===
metrics_all <- metrics_all |> 
  mutate(
    RMSE = if_else(Model == "Uden xreg", rmse_no_xreg, RMSE),
    MAPE = if_else(Model == "Uden xreg", mape_no_xreg, MAPE)
  )

# Print den opdaterede tabel
print(metrics_all)
```


```{r}
# Plot actual price vs forecast from Total Production lag 0 and lag 24
ggplot(forecast_comparison_all, aes(x = HourDK)) +
  geom_line(aes(y = actual, color = "Actual Price"), linewidth = 1.2) +
  geom_line(aes(y = forecast_total_lag0, color = "Forecast with Total Production (lag 0h)"), linewidth = 1.2) +
  geom_line(aes(y = forecast_total_lag24, color = "Forecast with Total Production (lag 24h)"), linewidth = 1.2) +
  scale_color_manual(values = c(
    "Actual Price" = "black",
    "Forecast with Total Production (lag 0h)" = "blue",
    "Forecast with Total Production (lag 24h)" = "forestgreen"
  )) +
  labs(
    title = "Forecast vs. Actual Electricity Spot Price (Feb 16)",
    x = "Hour",
    y = "Electricity Price (DKK)",
    color = "Legend"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

```
```{r}
# === NYT FORECAST: 3 dage (72 timer) ===
forecast_horizon <- 72

# Opdatér future_hours
future_hours_72 <- tibble(HourDK = max(train$HourDK) + seq(1, forecast_horizon) * 3600) |> 
  as_tsibble(index = HourDK)

# Opdatér fourier og t
t_future_72 <- max(t) + seq_len(forecast_horizon)
future_hours_72 <- future_hours_72 |> 
  mutate(t = t_future_72) |> 
  bind_cols(
    as_tibble(fourier(ts(train$logspotprice, frequency = 24), K = 6, h = forecast_horizon)),
    as_tibble(fourier(ts(train$logspotprice, frequency = 7*24), K = 5, h = forecast_horizon))
  )

# Forecast deterministisk komponent
future_deterministic_72 <- forecast(fit_dhr, new_data = future_hours_72) |>
  as_tibble() |> 
  rename(forecast_deterministic = .mean)

# Hent fremtidig total produktion
future_prod_72 <- productionConsumption |> 
  filter(HourDK >= as.POSIXct("2025-02-16 00:00:00") & HourDK < as.POSIXct("2025-02-19 00:00:00") + lubridate::days(1))

# Log-transformér totalProduction for lag 0 og lag 24
xreg_total_0_72 <- log(future_prod_72$totalProduction[1:forecast_horizon])
xreg_total_24_72 <- log(dplyr::lag(future_prod_72$totalProduction, 24)[25:(24 + forecast_horizon)])

# Forecasts for lag 0 og lag 24
forecast_total_0_72 <- forecast(model_totalProd_0, xreg = xreg_total_0_72) |> as_fable()
forecast_total_24_72 <- forecast(model_totalProd_24, xreg = xreg_total_24_72) |> as_fable()

# Kombinér og transformér til prisniveau
combined_forecast_total_0_72 <- future_deterministic_72 |> 
  bind_cols(forecast_random = forecast_total_0_72$.mean) |> 
  mutate(forecast_total_lag0 = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, forecast_total_lag0)

combined_forecast_total_24_72 <- future_deterministic_72 |> 
  bind_cols(forecast_random = forecast_total_24_72$.mean) |> 
  mutate(forecast_total_lag24 = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, forecast_total_lag24)

# Hent de faktiske elpriser for 3 dage
actual_prices_3days <- spotPrices |> 
  filter(HourDK >= as.POSIXct("2025-02-16 00:00:00") & 
         HourDK < as.POSIXct("2025-02-19 00:00:00")) |> 
  select(HourDK, SpotPriceDKK) |> 
  rename(actual = SpotPriceDKK)

# Saml alt i én data frame
forecast_comparison_3days <- actual_prices_3days |>
  left_join(combined_forecast_total_0_72, by = "HourDK") |>
  left_join(combined_forecast_total_24_72, by = "HourDK")

# === Plot ===
ggplot(forecast_comparison_3days, aes(x = HourDK)) +
  geom_line(aes(y = actual, color = "Actual Price"), linewidth = 1.2) +
  geom_line(aes(y = forecast_total_lag0, color = "Forecast with Total Production (lag 0h)"), linewidth = 1.2) +
  geom_line(aes(y = forecast_total_lag24, color = "Forecast with Total Production (lag 24h)"), linewidth = 1.2) +
  scale_color_manual(values = c(
    "Actual Price" = "black",
    "Forecast with Total Production (lag 0h)" = "blue",
    "Forecast with Total Production (lag 24h)" = "forestgreen"
  )) +
  labs(
    title = "Forecast vs. Actual Electricity Spot Price (Feb 16–18)",
    x = "Hour",
    y = "Electricity Price (DKK)",
    color = "Legend"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

```
```{r}
# === Forecast med manuel SARMA og auto.arima ===
fit_dhr <- train |>
  model(dhr = ARIMA(logspotprice ~ PDQ(0,0,0) + pdq(0,0,0) + t +
                      fourier(period = 24, K=6) + 
                      fourier(period = 7*24, K=5))) |>
              report() |> fitted() |> mutate(train$logspotprice)

#Udregn residualerne af den fittede model, kald dem "resids":
fit_dhr <- fit_dhr |> mutate(resids = train$logspotprice - .fitted, .model = NULL) 
fit_dhr <-  fit_dhr |> rename(deterministisk = .fitted, filtreret = resids)

# Genfit SARMA-modellen direkte på residualerne
model_SARMA <- train |> 
  mutate(filtreret = fit_dhr$filtreret) |> 
  model(sarma = ARIMA(filtreret ~ 1 + PDQ(1,1,1, period = 24) + pdq(1,0,1)))

# Forecast for 25 fremtidige timer
forecast_manual <- forecast(model_SARMA, h = 25) |> as_fable()
forecast_auto <- forecast(fit, h = 25) |> as_fable()

# Kombinér med deterministic komponent (future_deterministic og future_hours skal være defineret)
combined_manual <- future_deterministic |> 
  left_join(
    tibble(HourDK = future_hours$HourDK, forecast_random = forecast_manual$.mean),
    by = "HourDK"
  ) |> 
  mutate(forecast_manual = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, forecast_manual)

combined_auto <- future_deterministic |> 
  left_join(
    tibble(HourDK = future_hours$HourDK, forecast_random = forecast_auto$.mean),
    by = "HourDK"
  ) |> 
  mutate(forecast_auto = exp(forecast_deterministic + forecast_random)) |> 
  select(HourDK, forecast_auto)

# Hent faktiske priser fra 16. februar
actual_prices_feb16 <- spotPrices |> 
  filter(between(row_number(), 1850, 1873)) |> 
  as_tsibble(index = HourDK) |> 
  rename(actual_price = SpotPriceDKK)

# Sammenlign alle forecasts med faktiske priser
forecast_comparison <- actual_prices_feb16 |> 
  left_join(combined_manual, by = "HourDK") |> 
  left_join(combined_auto, by = "HourDK")

# Plot sammenligning
ggplot(forecast_comparison, aes(x = HourDK)) +
  geom_line(aes(y = actual_price, color = "Actual Price"), linewidth = 1.2) +
  geom_line(aes(y = forecast_manual, color = "Manual SARMA"), linewidth = 1.2) +
  geom_line(aes(y = forecast_auto, color = "Auto ARIMA"), linewidth = 1.2) +
  scale_color_manual(values = c(
    "Actual Price" = "black",
    "Manual SARMA" = "firebrick",
    "Auto ARIMA" = "steelblue"
  )) +
  labs(
    title = "Forecast Comparison: Manual SARMA vs. Auto ARIMA",
    x = "Hour",
    y = "Electricity Price (DKK)",
    color = "Legend"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")


# Evaluer RMSE og MAPE
rmse <- function(pred, actual) sqrt(mean((actual - pred)^2, na.rm = TRUE))
mape <- function(pred, actual) mean(abs((actual - pred) / actual), na.rm = TRUE) * 100

tibble(
  Model = c("Manual SARMA", "Auto ARIMA"),
  RMSE = c(
    rmse(forecast_comparison$forecast_manual, forecast_comparison$actual_price),
    rmse(forecast_comparison$forecast_auto, forecast_comparison$actual_price)
  ),
  MAPE = c(
    mape(forecast_comparison$forecast_manual, forecast_comparison$actual_price),
    mape(forecast_comparison$forecast_auto, forecast_comparison$actual_price)
  )
)

```

```{r}
#Dekompositions plottet
# Konverter priserne til en tidsserie
logspotprice_ts <- ts(train$logspotprice, frequency = 24)

# Brug decompose
decomposed <- decompose(logspotprice_ts, type = "additive")

# Plot
plot(decomposed)

```

```{r}
# ACF af random og seasonal komponent fra dekompositionen
acf(na.omit(decomposed$random), main = "ACF of Random Component", lag.max = 100, xlab = "Weeks")
acf(na.omit(decomposed$seasonal), main = "ACF of Seasonal Component",lag.max = 100, xlab = "Weeks")

```


